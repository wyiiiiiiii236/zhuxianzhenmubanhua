<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ±ä»™é•‡æœ¨ç‰ˆç”» - å®Œç¾è¿è¡Œç‰ˆ</title>

    <!-- çŠ¶æ€ç›‘æ§ & AI åº“ -->
    <script>
        window.isHandsLoaded = false;
        function onHandsLoaded() {
            console.log("MediaPipe Hands JS Loaded");
            window.isHandsLoaded = true;
            updateStatus("AI ç»„ä»¶å°±ç»ª", "#00eaff");
            const btn = document.getElementById('btn-webcam');
            if(btn) btn.style.opacity = "1";
        }

        // ç«‹å³é¢„è§ˆï¼šåœ¨ MediaPipe å‡†å¤‡å®Œä¹‹å‰ï¼ŒæŠŠåŸå§‹ video å¸§ç»˜åˆ¶åˆ° canvasï¼Œé¿å…é»‘å±
        function startImmediateVideoPreview() {
            if (window._immediatePreviewRunning) return;
            window._immediatePreviewRunning = true;
            const vid = document.getElementById('webcam-video');
            const cvs = document.getElementById('output-canvas');
            function loop() {
                if (!window._immediatePreviewRunning) return;
                if (window._handsReady) { window._immediatePreviewRunning = false; return; }
                if (vid && cvs && vid.videoWidth > 0) {
                    try {
                        cvs.width = vid.videoWidth; cvs.height = vid.videoHeight;
                        const ctx = cvs.getContext('2d'); ctx.drawImage(vid, 0, 0, cvs.width, cvs.height);
                    } catch (e) { /* ignore draw errors */ }
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }
        function updateStatus(text, color) {
            const el = document.getElementById('system-status');
            if(el) {
                el.innerText = text;
                el.style.color = color || '#fff';
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous" onload="onHandsLoaded()" onerror="alert('AIç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ')"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        /* --- åŸºç¡€è®¾ç½® --- */
        body { margin: 0; overflow: hidden; background-color: #020203; font-family: 'Inter', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* é¡¶éƒ¨ä¿¡æ¯ */
        #system-status {
            position: fixed; top: 10px; left: 10px; color: #aaa; font-size: 12px; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 6px 12px; border-radius: 20px; z-index: 200; pointer-events: none;
            border: 1px solid rgba(255,255,255,0.1); transition: color 0.3s;
        }
        #author-info {
            position: fixed; top: 45px; left: 15px; color: rgba(255, 255, 255, 0.5);
            font-size: 10px; z-index: 150; pointer-events: none; letter-spacing: 0.5px;
        }

        #loading { position: absolute; inset: 0; background: #000; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #00eaff; transition: opacity 0.5s; pointer-events: none; }

        /* --- æ‘„åƒå¤´ & æ‹–æ‹½ --- */
        #webcam-container { 
            position: fixed; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 50, 50, 0.5); 
            z-index: 50; background: #000; display: none; 
            pointer-events: auto; touch-action: none; cursor: move; 
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #webcam-video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; transform: scaleX(-1); }
        #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; pointer-events: none; position: absolute; top: 0; left: 0; }
        
        #touch-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; border: 2px solid rgba(0, 255, 170, 0.5); border-radius: 50%; pointer-events: none; display: none; z-index: 20; box-shadow: 0 0 20px rgba(0,255,170,0.3); }

        /* --- ç”»æ¿ (ç”µè„‘å¤§å±ç‰ˆ) --- */
        #drawing-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #drawing-modal.visible { display: flex; }
        .canvas-wrapper { 
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 16px; 
            overflow: hidden; background: #000; touch-action: none;
            max-width: 98vw; max-height: 95vh;
        }
        .modal-controls { display: flex; gap: 15px; margin-top: 20px; }
        .modal-btn { padding: 10px 25px; border-radius: 30px; border: 1px solid #444; background: #222; color: #fff; font-size: 14px; cursor: pointer; }
        .btn-confirm { background: #00ffaa; color: #000; border: none; }

        /* --- UI å¸ƒå±€ (é€šç”¨åŸºç¡€) --- */
        #ui {
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%);
            width: auto;
            max-width: 98%; 
            z-index: 10; 
            transition: opacity 0.3s ease, transform 0.3s ease; 
            opacity: 1; 
            pointer-events: none; 
        }
        #ui.hidden { opacity: 0; transform: translate(-50%, 50px); pointer-events: none; }

        .dock-panel { 
            background: rgba(12, 14, 18, 0.85);
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            padding: 12px 24px; border-radius: 24px; 
            pointer-events: auto; 
            display: flex; align-items: center; gap: 15px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.7); 
        }
        
        .divider { width: 1px; height: 24px; background: rgba(255, 255, 255, 0.15); margin: 0 5px; }
        .btn-group { display: flex; gap: 8px; align-items: center; }
        
        .shape-btn { 
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: #aaa; 
            padding: 8px 16px; border-radius: 12px; cursor: pointer; font-size: 13px; font-weight: 600; 
            white-space: nowrap; transition: all 0.2s; 
        }
        .shape-btn.active { color: #fff; background: rgba(255, 255, 255, 0.15); border-color: #00eaff; box-shadow: 0 0 10px rgba(0, 234, 255, 0.2); }
        /* é’ˆå¯¹ä¸åŒæŒ‰é’®çš„æ¿€æ´»è‰² */
        #btn-galaxy.active { color: #00eaff; }
        #btn-tesseract.active { color: #bd00ff; border-color: #bd00ff; box-shadow: 0 0 10px rgba(189, 0, 255, 0.2); }
        #btn-mobius.active { color: #aa55ff; border-color: #aa55ff; box-shadow: 0 0 10px rgba(170, 85, 255, 0.2); }
        
        /* ç”µè„‘ç‰ˆæ»‘å—ç»„ */
        .sliders-wrapper { display: flex; align-items: center; gap: 15px; }
        .slider-group { display: flex; align-items: center; gap: 8px; min-width: 100px; }
        .slider-label { font-size: 12px; font-weight: 700; color: #00eaff; white-space: nowrap; }
        
        /* --- æ»‘å—æ ·å¼ --- */
        input[type="range"] { 
            flex: 1; 
            -webkit-appearance: none; 
            height: 4px; 
            background: rgba(255,255,255,0.15); 
            border-radius: 2px; 
            width: 80px; 
            cursor: pointer; 
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; 
            height: 14px;
            border-radius: 50%;
            background: #0099ff; 
            box-shadow: 0 0 5px rgba(0, 153, 255, 0.5); 
            margin-top: -5px; 
            border: none;
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #0099ff;
            border: none;
            box-shadow: 0 0 5px rgba(0, 153, 255, 0.5);
        }
        
        /* --- é¢œè‰²è§¦å‘å™¨ --- */
        .color-dock-section { 
            display: flex; align-items: center; gap: 12px; 
            background: none; padding: 0; border: none; 
        }
        .trigger-group { display: flex; gap: 12px; align-items: center; position: relative; }
        .trigger-item { display: flex; flex-direction: column; align-items: center; gap: 0px; cursor: pointer; }
        
        .color-trigger {
            width: 24px; height: 24px; border-radius: 50%; 
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            position: relative; transition: all 0.2s; transform: scale(1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .trigger-item:hover .color-trigger { transform: scale(1.1); border-color: #fff; }
        .trigger-label { display: none; } 
        
        /* --- é¢œè‰²é¢æ¿ --- */
        #custom-color-picker {
            position: absolute; bottom: 60px; right: 0; width: 260px;
            background: rgba(20, 20, 25, 0.95); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 16px; padding: 16px;
            display: none; flex-direction: column; gap: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 200;
        }
        #custom-color-picker.visible { display: flex; animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { opacity: 0; transform: scale(0.9) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }

        .picker-header { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: #aaa; font-weight: bold; }
        .picker-close { cursor: pointer; padding: 4px; font-size: 14px; }
        .picker-close:hover { color: #fff; }

        .picker-sl { width: 100%; height: 100px; background: red; position: relative; border-radius: 8px; cursor: crosshair; background-image: linear-gradient(to right, #fff, rgba(255,255,255,0)), linear-gradient(to top, #000, rgba(0,0,0,0)); }
        .picker-sl-thumb { width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%; position: absolute; transform: translate(-50%, -50%); box-shadow: 0 0 5px rgba(0,0,0,0.5); pointer-events: none; }
        .picker-hue { width: 100%; height: 12px; border-radius: 6px; cursor: pointer; position: relative; background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); }
        .picker-hue-thumb { width: 12px; height: 12px; background: #fff; border-radius: 50%; position: absolute; top: 0; transform: translateX(-50%); box-shadow: 0 0 2px rgba(0,0,0,0.5); pointer-events: none; }

        .picker-rgb { display: flex; gap: 8px; justify-content: space-between; }
        .rgb-input { flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; padding: 4px; text-align: center; font-size: 12px; font-family: monospace; }
        .rgb-label { color: #888; font-size: 10px; text-align: center; margin-top: 2px; }

        .picker-presets { display: flex; justify-content: space-between; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; }
        .preset-btn { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 1px solid rgba(255,255,255,0.2); transition: transform 0.2s; }
        .preset-btn:hover { transform: scale(1.1); border-color: #fff; }

        /* éšè—â€œç‚¹æ­¤é€€å‡ºå…¨å±â€æŒ‰é’® */
        #restore-ui-btn { display: none !important; }

        /* --- æ‰‹æœºç«¯ä¸“å±æ ·å¼ --- */
        /* å…¨å±æŒ‰é’®æ‚¬æµ®å³ä¸Šè§’ */
        .mobile-fab-btn {
            position: fixed !important;
            top: 15px; right: 15px;
            width: 44px; height: 44px; padding: 0;
            border-radius: 50%;
            z-index: 301 !important;
            background: rgba(12, 14, 18, 0.6);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center;
            font-size: 0 !important;
        }
        .mobile-fab-btn::after { content: 'â›¶'; font-size: 20px; color: #fff; }

        /* æ‰‹æœºç«¯å¸ƒå±€è°ƒæ•´ */
        @media (max-width: 850px) {
            #ui { bottom: 20px; width: 100%; max-width: 100%; transform: translateX(-50%); left: 50%; } 
            
            .dock-panel { 
                flex-direction: column; 
                padding: 12px; gap: 15px; 
                width: 96%; box-sizing: border-box; border-radius: 24px; 
            }
            .divider { display: none; }
            
            .btn-group { 
                width: 100%; overflow-x: auto; 
                justify-content: flex-start;
                gap: 8px; padding-bottom: 2px;
                -webkit-overflow-scrolling: touch;
            }
            .btn-group::-webkit-scrollbar { display: none; }
            
            .shape-btn { flex: 0 0 auto; padding: 8px 16px; font-size: 12px; }

            .sliders-wrapper { flex-direction: row; width: 100%; justify-content: space-between; gap: 8px; flex-wrap: nowrap; }
            .slider-group { min-width: 0; flex: 1; display: flex; flex-direction: column; align-items: flex-start; gap: 5px; }
            input[type="range"] { 
                width: 100%; 
                height: 6px; 
                background: rgba(255,255,255,0.1); 
            }
            input[type="range"]::-webkit-slider-thumb {
                width: 18px; height: 18px;
                background: #fff;
                margin-top: -6px;
                box-shadow: 0 0 8px rgba(255,255,255,0.6);
            }
            
            #webcam-container { 
                width: 100px; height: 133px; 
                top: 80px; left: 15px; 
                bottom: auto; right: auto; 
                border: 1px solid rgba(255, 50, 50, 0.5);
            }
            
            /* æ‰‹æœºç«¯åº•éƒ¨ä¸€è¡Œå·¥å…·æ å®¹å™¨ */
            #mobile-tools-row {
                display: flex;
                align-items: center;
                justify-content: flex-start; /* é å·¦å¯¹é½ */
                width: 100%;
                gap: 15px; /* å…ƒç´ é—´è· */
                margin-top: 5px;
            }

            /* æ‰‹æœºç«¯é¢œè‰²åŒºåŸŸï¼šæ— æ¡†ï¼Œæ¨ªå‘ */
            .color-dock-section {
                padding: 0;
                margin: 0;
                background: none !important; /* ç§»é™¤å¤–æ¡†èƒŒæ™¯ */
                border: none !important; /* ç§»é™¤è¾¹æ¡† */
                width: auto;
                position: relative; /* æ¢å¤å®šä½ä¸Šä¸‹æ–‡ */
            }
            .trigger-group {
                flex-direction: row !important; /* å¼ºåˆ¶æ¨ªå‘ */
                gap: 15px !important;
                position: relative; /* ç¡®ä¿å­ç»å¯¹å®šä½å‚è€ƒå®ƒ */
            }
            
            /* ä¿®å¤ï¼šé¢œè‰²é¢æ¿åœ¨æ‰‹æœºç«¯å¼ºåˆ¶å±å¹•å±…ä¸­ fixed å®šä½ */
            #custom-color-picker { 
                position: fixed !important; /* å¼ºåˆ¶åŸºäºçª—å£å®šä½ï¼Œé˜²æ­¢è·‘å */
                bottom: 140px !important; /* è·ç¦»åº•éƒ¨çš„é«˜åº¦ï¼Œé¿å¼€UIæ  */
                left: 50% !important; /* æ°´å¹³å±…ä¸­èµ·ç‚¹ */
                right: auto !important; 
                top: auto !important;
                width: 260px !important; /* å¼ºåˆ¶å›ºå®šå®½åº¦ */
                transform: translateX(-50%) !important; /* çœŸæ­£çš„æ°´å¹³å±…ä¸­ä¿®æ­£ */
                z-index: 500;
                margin: 0;
            }

            /* é¢œè‰²è§¦å‘å™¨å°ºå¯¸ (ä¿æŒä¸å…¨å±æŒ‰é’®ä¸€è‡´) */
            .color-trigger {
                width: 44px !important;
                height: 44px !important;
                box-sizing: border-box !important;
                border: 2px solid rgba(255,255,255,0.1) !important;
            }
            .trigger-item { margin: 0; }
        }
    </style>
</head>
<body>

    <div id="system-status">æ­£åœ¨åˆå§‹åŒ–...</div>
    <div id="author-info">Author:å»ºç­‘å¸ˆå´æ€¡   Particle System Version 1.0</div>

    <div id="loading">
        <h2 style="font-weight:300; letter-spacing:4px; font-size: 20px;">SYSTEM LOADING</h2>
    </div>
    
    <!-- éšè—é€€å‡ºå…¨å±æŒ‰é’® -->
    <div id="restore-ui-btn" onclick="toggleImmersive()">ğŸ‘† ç‚¹æ­¤é€€å‡ºå…¨å±</div>

    <div id="touch-indicator"></div>
    <div id="canvas-container"></div>

    <div id="webcam-container">
        <video id="webcam-video" playsinline webkit-playsinline muted autoplay></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="drawing-modal">
        <div style="color: #aaa; font-size: 12px; margin-bottom: 15px;">è¯·åœ¨ä¸‹æ–¹åŒºåŸŸç»˜åˆ¶å›¾å½¢</div>
        <div class="canvas-wrapper">
            <canvas id="paint-canvas"></canvas>
        </div>
        <div class="modal-controls">
            <button class="modal-btn" onclick="clearCanvas()">æ¸…ç©º</button>
            <button class="modal-btn" onclick="closeModal()">å–æ¶ˆ</button>
            <button class="modal-btn btn-confirm" onclick="confirmDrawing()">ç”Ÿæˆç²’å­</button>
        </div>
    </div>

    <div id="ui">
        <div class="dock-panel" id="main-dock">
            <div class="btn-group" id="main-btns">
                <button id="btn-galaxy" class="shape-btn active" onclick="setMode('galaxy')">èµµå…¬æ˜</button>
                <button id="btn-tesseract" class="shape-btn" onclick="setMode('tesseract')">å¢ç¦è´¢ç¥</button>
                <button id="btn-mobius" class="shape-btn" onclick="setMode('mobius')">å…³ç¾½</button>
                <button id="btn-draw" class="shape-btn" onclick="openDrawingModal()">ğŸ–Œï¸ æ‰‹ç»˜</button>
                <button id="btn-webcam" class="shape-btn" onclick="attemptWebcam()">ğŸ“· æ‰‹åŠ¿æ§åˆ¶</button>
                <button id="btn-immersive" class="shape-btn" onclick="toggleImmersive()">â›¶ å…¨å±</button>
                <button id="btn-custom" class="shape-btn" style="display:none;">è‡ªå®šä¹‰</button>
                <!-- æ–°å¢ä¸»é¡µæŒ‰é’® (é»˜è®¤æ”¾åœ¨æŒ‰é’®ç»„é‡Œï¼Œæ‰‹æœºç«¯ä¼šè¢«ç§»èµ°) -->
                <button id="btn-homepage" class="shape-btn" onclick="window.open('https://www.xiaohongshu.com/user/profile/5e44e28b000000000100b0aa')">ğŸ  ä¸»é¡µ</button>
            </div>
            <div class="divider"></div>
            <div class="sliders-wrapper">
                <div class="slider-group">
                    <span class="slider-label">æ··æ²Œ</span>
                    <input type="range" id="chaos-slider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="slider-group">
                    <span class="slider-label">å¯†åº¦</span>
                    <input type="range" id="model-density-slider" min="0" max="150000" step="100" value="150000">
                </div>
                <div class="slider-group">
                    <span class="slider-label">æ‰©æ•£</span>
                    <input type="range" id="spread-slider" min="0" max="2.0" step="0.01" value="0.0">
                </div>
            </div>
            <div class="divider"></div>
            <div class="color-dock-section" id="color-dock">
                <div class="trigger-group">
                    <div class="trigger-item" id="item-core" onclick="openColorPicker('core')">
                        <div id="trigger-core" class="color-trigger" style="background: #ffaa33"></div>
                        <div class="trigger-label">æ ¸å¿ƒ</div>
                    </div>
                    <div class="trigger-item" id="item-edge" onclick="openColorPicker('edge')">
                        <div id="trigger-edge" class="color-trigger" style="background: #1b3984"></div>
                        <div class="trigger-label">è¾¹ç¼˜</div>
                    </div>

                    <!-- é¢œè‰²é¢æ¿ -->
                    <div id="custom-color-picker">
                        <div class="picker-header">
                            <span id="picker-title">ç¼–è¾‘é¢œè‰²</span>
                            <span class="picker-close" onclick="closeColorPicker(event)">âœ•</span>
                        </div>
                        
                        <div class="picker-sl" id="picker-sl" onmousedown="startSlDrag(event)" ontouchstart="startSlDrag(event)">
                            <div class="picker-sl-thumb" id="picker-sl-thumb"></div>
                        </div>
                        
                        <div class="picker-hue" id="picker-hue" onmousedown="startHueDrag(event)" ontouchstart="startHueDrag(event)">
                            <div class="picker-hue-thumb" id="picker-hue-thumb"></div>
                        </div>

                        <div class="picker-rgb">
                            <div><input type="number" id="rgb-r" class="rgb-input" min="0" max="255"><div class="rgb-label">R</div></div>
                            <div><input type="number" id="rgb-g" class="rgb-input" min="0" max="255"><div class="rgb-label">G</div></div>
                            <div><input type="number" id="rgb-b" class="rgb-input" min="0" max="255"><div class="rgb-label">B</div></div>
                        </div>

                        <div class="picker-presets">
                            <div class="preset-btn" style="background: #ffaa33" onclick="setSingleColor('#ffaa33')" title="é‡‘"></div>
                            <div class="preset-btn" style="background: #00ffcc" onclick="setSingleColor('#00ffcc')" title="é’"></div>
                            <div class="preset-btn" style="background: #ff3300" onclick="setSingleColor('#ff3300')" title="çº¢"></div>
                            <div class="preset-btn" style="background: #bd00ff" onclick="setSingleColor('#bd00ff')" title="ç´«"></div>
                            <div class="preset-btn" style="background: #0066ff" onclick="setSingleColor('#0066ff')" title="è“"></div>
                            <div class="preset-btn" style="background: #ffffff" onclick="setSingleColor('#ffffff')" title="ç™½"></div>
                            <div class="preset-btn" style="background: #000000" onclick="setSingleColor('#000000')" title="é»‘"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- ç”µè„‘ç‰ˆä¸»é¡µæŒ‰é’® (æ‰‹æœºç‰ˆä¼šç§»åŠ¨ä½ç½®) -->
            <div class="divider" id="pc-divider-2"></div>
            <!-- ä¸»é¡µæŒ‰é’®åœ¨JSä¸­ä¼šè¢«ç§»åŠ¨ -->
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        let scene, camera, renderer, composer, controls, particleSystem, material, bgParticles;
        const count = 150000;
        const mouse = new THREE.Vector2(-9999, -9999);
        
        window.isWebcamOn = false;
        window.isTouchMode = false;
        window.isWebcamLoading = false; // æ‘„åƒå¤´åŠ è½½é”
        window.videoStream = null;
        window.hands = null;
        let handOpenness = 0, handX = 0, smoothedOpenness = 0;
        let isDrawing = false, lastX = 0, lastY = 0;
        const paintCanvas = document.getElementById('paint-canvas');
        const ctx = paintCanvas.getContext('2d');

        // --- DOM æ“ä½œè¾…åŠ© ---
        function checkMobileUI() {
            const isMobile = window.innerWidth <= 850;
            const btnImm = document.getElementById('btn-immersive');
            const colorDock = document.getElementById('color-dock');
            const mainBtns = document.getElementById('main-btns');
            const mainDock = document.getElementById('main-dock');
            const pcDivider = document.getElementById('pc-divider-2');
            
            // è·å–éœ€è¦æ”¹åçš„æŒ‰é’®
            const btnTesseract = document.getElementById('btn-tesseract');
            const btnMobius = document.getElementById('btn-mobius');
            const btnWebcam = document.getElementById('btn-webcam');
            const btnHomepage = document.getElementById('btn-homepage');
            const btnCustom = document.getElementById('btn-custom'); // è·å–éšè—çš„è‡ªå®šä¹‰æŒ‰é’®ä½œä¸ºé”šç‚¹

            // æ£€æŸ¥æˆ–åˆ›å»ºæ‰‹æœºç«¯åº•éƒ¨ä¸“ç”¨è¡Œå®¹å™¨
            let mobileRow = document.getElementById('mobile-tools-row');
            if (isMobile && !mobileRow) {
                mobileRow = document.createElement('div');
                mobileRow.id = 'mobile-tools-row';
                mainDock.appendChild(mobileRow);
            }

            if (isMobile) {
                // --- æ‰‹æœºç‰ˆå¸ƒå±€é‡ç»„ ---
                if (pcDivider) pcDivider.style.display = 'none';

                // 1. å…¨å±æŒ‰é’®ï¼šç§»åˆ°å³ä¸Šè§’æ‚¬æµ® (Mobile FAB)
                if (btnImm.parentElement !== document.body) {
                    document.body.appendChild(btnImm);
                    btnImm.classList.add('mobile-fab-btn');
                }
                
                // 2. é¢œè‰²ã€äº¤äº’ã€ä¸»é¡µï¼šç§»å…¥åº•éƒ¨æ–°è¡Œ
                if (colorDock.parentElement !== mobileRow) mobileRow.appendChild(colorDock);
                if (btnWebcam.parentElement !== mobileRow) mobileRow.appendChild(btnWebcam);
                if (btnHomepage.parentElement !== mobileRow) mobileRow.appendChild(btnHomepage);

                // --- æ‰‹æœºç‰ˆæ–‡æ¡ˆè°ƒæ•´ ---
                if(btnTesseract) btnTesseract.innerText = "å››ç»´";
                if(btnMobius) btnMobius.innerText = "è«æ¯”ä¹Œæ–¯"; // æ¢å¤ä¸ºâ€œè«æ¯”ä¹Œæ–¯â€
                if(btnWebcam) btnWebcam.innerText = "ğŸ“· äº¤äº’"; 

            } else {
                // --- ç”µè„‘ç‰ˆå¸ƒå±€è¿˜åŸ ---
                if (pcDivider) pcDivider.style.display = 'block';

                // ç§»é™¤æ‰‹æœºç«¯ä¸“ç”¨è¡Œ (å¦‚æœå­˜åœ¨ï¼Œå…ˆå°†å…ƒç´ ç§»å›åŸä½å†åˆ é™¤)
                if (mobileRow) {
                    // ç§»å›ä¸»æŒ‰é’®ç»„ï¼šäº¤äº’æŒ‰é’®æ’åœ¨è‡ªå®šä¹‰æŒ‰é’®ä¹‹å‰
                    // æ£€æŸ¥çˆ¶å­å…³ç³»
                    if (btnCustom.parentNode === mainBtns) {
                        mainBtns.insertBefore(btnWebcam, btnCustom); 
                    } else {
                        mainBtns.appendChild(btnWebcam);
                    }
                    
                    // ä¸»é¡µæŒ‰é’®æ”¾å›Dockæœ€å
                    mainDock.appendChild(btnHomepage);
                    
                    // é¢œè‰²åŒºåŸŸæ”¾å›ä¸»Dock (æ’åœ¨pcDividerä¹‹å‰)
                    if (pcDivider.parentNode === mainDock) {
                        mainDock.insertBefore(colorDock, pcDivider);
                    } else {
                        mainDock.appendChild(colorDock);
                    }
                    
                    mobileRow.remove();
                }

                // å…¨å±æŒ‰é’®æ”¾å› (æ’åœ¨è‡ªå®šä¹‰æŒ‰é’®ä¹‹å‰)
                if (btnImm.parentElement === document.body) {
                    if (btnCustom.parentNode === mainBtns) {
                        mainBtns.insertBefore(btnImm, btnCustom); 
                    } else {
                        mainBtns.appendChild(btnImm);
                    }
                    btnImm.classList.remove('mobile-fab-btn');
                    btnImm.innerText = "â›¶ å…¨å±";
                }
                
                // PCç«¯æ–‡å­—æ¢å¤
                if(btnTesseract) btnTesseract.innerText = "å¢ç¦è´¢ç¥";
                if(btnMobius) btnMobius.innerText = "å…³ç¾½";
                if(btnWebcam) btnWebcam.innerText = window.isWebcamOn ? "ğŸ“· è¿è¡Œä¸­" : "ğŸ“· æ‰‹åŠ¿æ§åˆ¶";
                // ç¡®ä¿ä¸»é¡µæŒ‰é’®åœ¨PCç«¯ä¹Ÿå­˜åœ¨äºDockæœ«å°¾
                if(btnHomepage.parentElement !== mainDock) {
                    mainDock.appendChild(btnHomepage);
                }
            }
        }

        // --- å·¥å…·å‡½æ•° ---
        function bindEvent(id, event, handler) {
            const el = document.getElementById(id);
            if(el) el[event] = handler;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        function hslToHex(h, s, l) {
            l /= 100; const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        // --- é¢œè‰²é€»è¾‘ ---
        let currentTarget = 'core';

        window.openColorPicker = (target) => {
            currentTarget = target;
            document.getElementById('picker-title').innerText = target === 'core' ? 'ç¼–è¾‘æ ¸å¿ƒé¢œè‰²' : 'ç¼–è¾‘è¾¹ç¼˜é¢œè‰²';
            document.getElementById('custom-color-picker').classList.add('visible');
            document.getElementById('item-core').classList.remove('active');
            document.getElementById('item-edge').classList.remove('active');
            document.getElementById('item-' + target).classList.add('active');
        };

        window.closeColorPicker = (e) => {
            if(e) e.stopPropagation();
            document.getElementById('custom-color-picker').classList.remove('visible');
            document.getElementById('item-core').classList.remove('active');
            document.getElementById('item-edge').classList.remove('active');
        };

        window.setSingleColor = (hex) => {
            updateColor(hex);
            const rgb = hexToRgb(hex);
            if(rgb) {
                document.getElementById('rgb-r').value = rgb.r;
                document.getElementById('rgb-g').value = rgb.g;
                document.getElementById('rgb-b').value = rgb.b;
            }
        };

        function updateColor(hex) {
            const trigger = document.getElementById('trigger-' + currentTarget);
            if(trigger) trigger.style.background = hex;
            if(material) {
                if(currentTarget === 'core') material.uniforms.uColorInside.value.set(hex);
                else material.uniforms.uColorOutside.value.set(hex);
            }
            if(currentTarget === 'edge' && bgParticles && bgParticles.material) {
                bgParticles.material.uniforms.uColor.value.set(hex);
            }
        }

        // é¢œè‰²æ‹–æ‹½
        window.startHueDrag = (e) => {
            const bar = document.getElementById('picker-hue');
            const handleDrag = (ev) => {
                ev.preventDefault();
                const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                const rect = bar.getBoundingClientRect();
                let x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                document.getElementById('picker-hue-thumb').style.left = (x * 100) + '%';
                const hex = hslToHex(x * 360, 100, 50);
                document.getElementById('picker-sl').style.backgroundColor = hex;
                updateColor(hex);
            };
            const stopDrag = () => {
                window.removeEventListener('mousemove', handleDrag); window.removeEventListener('touchmove', handleDrag);
                window.removeEventListener('mouseup', stopDrag); window.removeEventListener('touchend', stopDrag);
            };
            window.addEventListener('mousemove', handleDrag); window.addEventListener('touchmove', handleDrag, {passive:false});
            window.addEventListener('mouseup', stopDrag); window.addEventListener('touchend', stopDrag);
            handleDrag(e);
        };
        
        window.startSlDrag = (e) => {
            const box = document.getElementById('picker-sl');
            const handleDrag = (ev) => {
                ev.preventDefault();
                const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
                const rect = box.getBoundingClientRect();
                let x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                let y = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
                const thumb = document.getElementById('picker-sl-thumb');
                thumb.style.left = (x * 100) + '%'; thumb.style.top = (y * 100) + '%';
            };
            const stopDrag = () => {
                window.removeEventListener('mousemove', handleDrag); window.removeEventListener('touchmove', handleDrag);
                window.removeEventListener('mouseup', stopDrag); window.removeEventListener('touchend', stopDrag);
            };
            window.addEventListener('mousemove', handleDrag); window.addEventListener('touchmove', handleDrag, {passive:false});
            window.addEventListener('mouseup', stopDrag); window.addEventListener('touchend', stopDrag);
            handleDrag(e);
        };

        const updateFromRGB = () => {
            const r = Math.min(255, Math.max(0, parseInt(document.getElementById('rgb-r').value) || 0));
            const g = Math.min(255, Math.max(0, parseInt(document.getElementById('rgb-g').value) || 0));
            const b = Math.min(255, Math.max(0, parseInt(document.getElementById('rgb-b').value) || 0));
            updateColor(rgbToHex(r,g,b));
        };

        // --- åˆå§‹åŒ– ---
        async function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.002);
            scene.background = new THREE.Color(0x020205);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 45);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchmove', onTouchSimulate, { passive: false });
            document.addEventListener('click', (e) => {
                const picker = document.getElementById('custom-color-picker');
                const triggers = document.getElementById('color-dock'); 
                if (picker && picker.classList.contains('visible')) {
                    if(!picker.contains(e.target) && !triggers.contains(e.target)) {
                        closeColorPicker();
                    }
                }
            });

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5;

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene); composer.addPass(bloomPass);

            await createMainParticles();
            createBackgroundParticles();
            
            setupUI();
            checkMobileUI(); 
            initDraggable(document.getElementById('webcam-container'));
            
            document.getElementById('loading').style.display = 'none';
            if(window.isHandsLoaded) updateStatus("ç³»ç»Ÿå°±ç»ª", "#fff");
            else updateStatus("ç­‰å¾… AI ç»„ä»¶...", "#aaa");
            
            window.addEventListener('resize', onWindowResize);
        }

        function setupUI() {
            bindEvent('chaos-slider', 'oninput', (e) => material.uniforms.uChaos.value = parseFloat(e.target.value));
            bindEvent('model-density-slider', 'oninput', (e) => { if(particleSystem) particleSystem.geometry.setDrawRange(0, parseInt(e.target.value)); });
            bindEvent('spread-slider', 'oninput', (e) => { if(!window.isWebcamOn && !window.isTouchMode) material.uniforms.uSpread.value = parseFloat(e.target.value); });
            bindEvent('rgb-r', 'oninput', updateFromRGB);
            bindEvent('rgb-g', 'oninput', updateFromRGB);
            bindEvent('rgb-b', 'oninput', updateFromRGB);
        }

        // --- æ¨¡å‹ä¸Šä¼ ä¸é‡‡æ ·ï¼ˆæ¥è‡ª test.html çš„å®ç°ï¼‰ ---
        window.openModelPicker = (mode) => {
            const inputId = 'model-input-' + mode;
            let inp = document.getElementById(inputId);
            if(!inp) {
                inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.glb,.gltf,.obj'; inp.id = inputId; inp.style.display = 'none';
                inp.addEventListener('change', (e) => handleModelFile(mode, e.target.files[0]));
                document.body.appendChild(inp);
            }
            inp.click();
        };

        async function handleModelFile(mode, file) {
            if(!file) return;
            updateStatus('åŠ è½½æ¨¡å‹ä¸­...', '#00eaff');
            const url = URL.createObjectURL(file);
            try {
                let obj = null;
                if(file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
                    const loader = new GLTFLoader();
                    const res = await loader.loadAsync(url);
                    obj = res.scene;
                } else if(file.name.toLowerCase().endsWith('.obj')) {
                    const loader = new OBJLoader();
                    // OBJLoader may not have loadAsync; wrap if necessary
                    if (loader.loadAsync) {
                        obj = await loader.loadAsync(url);
                    } else {
                        obj = await new Promise((resolve, reject) => loader.load(url, resolve, undefined, reject));
                    }
                }
                if(!obj) throw new Error('ä¸æ”¯æŒçš„æ¨¡å‹');
                // æ”¶é›†ä½ç½®å¹¶å†™å›ç²’å­ç›®æ ‡
                const samples = collectPositionsFromObject(obj, count);
                applySamplesToMode(mode, samples);
                updateStatus('æ¨¡å‹å·²åŠ è½½å¹¶åº”ç”¨', '#00ffaa');
            } catch (e) {
                console.error(e);
                updateStatus('æ¨¡å‹åŠ è½½å¤±è´¥', '#ff5555');
                alert('æ¨¡å‹åŠ è½½å¤±è´¥: ' + (e && e.message ? e.message : e));
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function collectPositionsFromObject(object3D, targetCount) {
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ª Mesh
            let mesh = null;
            object3D.traverse(c => { if(!mesh && c.isMesh) mesh = c; });
            if(!mesh) return null;
            // ä¿è¯å‡ ä½•ä½“æ˜¯ BufferGeometry
            const geom = mesh.geometry.isBufferGeometry ? mesh.geometry : new THREE.BufferGeometry().fromGeometry(mesh.geometry);
            const sampler = new MeshSurfaceSampler(mesh).build();
            const pos = [];
            const _position = new THREE.Vector3();
            for(let i=0;i<targetCount;i++) {
                sampler.sample(_position);
                pos.push(_position.x, _position.y, _position.z);
            }
            // å½’ä¸€åŒ–ä¸ç¼©æ”¾åˆ°é€‚é…ç”»é¢
            return normalizeAndScalePositions(pos);
        }

        function normalizeAndScalePositions(flatPos) {
            if(!flatPos || flatPos.length===0) return null;
            let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
            for(let i=0;i<flatPos.length;i+=3) {
                const x=flatPos[i], y=flatPos[i+1], z=flatPos[i+2];
                if(x<minX)minX=x; if(y<minY)minY=y; if(z<minZ)minZ=z;
                if(x>maxX)maxX=x; if(y>maxY)maxY=y; if(z>maxZ)maxZ=z;
            }
            const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2;
            const span = Math.max(maxX-minX, maxY-minY, maxZ-minZ);
            const scale = span>0 ? 30.0 / span : 1.0;
            const out = new Float32Array(flatPos.length);
            for(let i=0;i<flatPos.length;i+=3) {
                out[i] = (flatPos[i]-cx) * scale;
                out[i+1] = (flatPos[i+1]-cy) * scale;
                out[i+2] = (flatPos[i+2]-cz) * scale;
            }
            return out;
        }

        function applySamplesToMode(mode, floatArr) {
            if(!floatArr) { alert('æ— æ³•ä»æ¨¡å‹é‡‡æ ·åˆ°ç‚¹'); return; }
            const attrName = mode === 'galaxy' ? 'targetGalaxy' : mode === 'tesseract' ? 'targetTesseract' : 'targetMobius';
            const attr = particleSystem.geometry.attributes[attrName];
            if(!attr) { alert('ç²’å­å±æ€§ä¸å­˜åœ¨'); return; }
            const arr = attr.array;
            for(let i=0;i<arr.length;i++) {
                arr[i] = floatArr[i % floatArr.length] + (Math.random()-0.5)*0.5;
            }
            particleSystem.geometry.attributes[attrName].needsUpdate = true;
        }

        window.attemptWebcam = attemptWebcam;
        window.toggleImmersive = toggleImmersive;
        window.setMode = setMode;
        window.clearCanvas = () => { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, paintCanvas.width, paintCanvas.height); };
        window.openDrawingModal = () => { document.getElementById('drawing-modal').classList.add('visible'); setTimeout(initPaintCanvas, 50); window.clearCanvas(); };
        window.closeModal = () => document.getElementById('drawing-modal').classList.remove('visible');

            document.addEventListener('DOMContentLoaded', async () => {
            await init();
            animate();
        });

        // --- åŠŸèƒ½å‡½æ•° ---
        function toggleImmersive() {
            const ui = document.getElementById('ui');
            const restoreBtn = document.getElementById('restore-ui-btn');
            
            if(ui.classList.contains('hidden')) {
                ui.classList.remove('hidden');
                // æ¢å¤å…¨å±æ—¶ä»€ä¹ˆéƒ½ä¸æ˜¾ç¤º
                if(document.exitFullscreen) document.exitFullscreen().catch(()=>{});
            } else {
                ui.classList.add('hidden');
                // è¿›å…¥å…¨å±æ—¶ä¸æ˜¾ç¤ºæ¢å¤æŒ‰é’®
                if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
            }
        }

        async function attemptWebcam() {
            const btn = document.getElementById('btn-webcam');
            const isMobile = window.innerWidth <= 850;
            if (!window.isHandsLoaded) { alert("AI ç»„ä»¶å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨ç­‰å‡ ç§’ã€‚"); return; }
            
            if (window.isWebcamLoading) return; // é˜²æ­¢é‡å¤ç‚¹å‡»

            // å…³é—­é€»è¾‘ï¼šå½»åº•æ¸…é™¤æµï¼Œé˜²æ­¢å¡æ­»
            if (window.isWebcamOn || window.isTouchMode) {
                window.isWebcamLoading = true;
                window.isWebcamOn = false; 
                window.isTouchMode = false;
                btn.classList.remove('active');
                document.getElementById('webcam-container').style.display = 'none';
                
                // åœæ­¢æ‰€æœ‰è½¨é“
                if (window.videoStream) { 
                    window.videoStream.getTracks().forEach(t => t.stop()); 
                    window.videoStream = null; 
                }
                
                // å…³é”®ï¼šå½»åº•é‡ç½® video å…ƒç´ ï¼Œè§£å†³ç§»åŠ¨ç«¯å¡ä½é—®é¢˜
                const video = document.getElementById('webcam-video');
                video.pause();
                video.srcObject = null;
                // video.load() ç§»é™¤ï¼Œè§£å†³æ­»å¾ªç¯é—®é¢˜

                handOpenness = 0; handX = 0;
                if(material) material.uniforms.uSpread.value = 0;
                if(controls) controls.autoRotate = true;
                
                // æ¢å¤æ–‡æ¡ˆ
                if (!isMobile) btn.innerText = "ğŸ“· æ‰‹åŠ¿æ§åˆ¶";
                if (isMobile) btn.innerText = "ğŸ“· äº¤äº’";
                
                btn.style.boxShadow = ""; btn.style.color = ""; btn.style.borderColor = "";
                updateStatus("æ‘„åƒå¤´å·²å…³é—­", "#fff");
                
                window.isWebcamLoading = false;
                return;
            }

            // å¼€å¯é€»è¾‘
            window.isWebcamLoading = true;
            btn.classList.add('active');
            if(!isMobile) btn.innerText = "â³ è¯·æ±‚ä¸­...";
            if(isMobile) btn.innerText = "ğŸ“· äº¤äº’"; // ä¿æŒæ–‡å­—ä¸å˜
            
            updateStatus("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´...", "#00eaff");

            const constraints = {
                audio: false,
                video: {
                    facingMode: 'user', 
                    ...(isMobile ? {} : { width: { ideal: 320 }, height: { ideal: 240 } })
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                window.videoStream = stream;
                const video = document.getElementById('webcam-video');
                video.srcObject = stream;
                
                document.getElementById('webcam-container').style.display = 'block';
                
                try {
                    await video.play();
                } catch(e) {
                    console.warn("Auto-play failed", e);
                }

                // ç«‹å³å¯åŠ¨åŸå§‹è§†é¢‘é¢„è§ˆï¼Œç›´åˆ° MediaPipe å¼€å§‹è¾“å‡ºï¼ˆé¿å…é»‘å±ï¼‰
                try { video.style.opacity = '1'; } catch(e) {}
                startImmediateVideoPreview();

                // ä¸ä¾èµ– onloadedmetadataï¼Œç›´æ¥æ ‡è®°å®Œæˆ
                window.isWebcamOn = true; 
                window.isWebcamLoading = false;
                if(controls) controls.autoRotate = false;
                if(!isMobile) btn.innerText = "ğŸ“· è¿è¡Œä¸­";
                if(isMobile) btn.innerText = "ğŸ“· äº¤äº’";
                
                initMediaPipe();
                updateStatus("æ‘„åƒå¤´å·²å¯åŠ¨", "#00ffaa");

            } catch (err) {
                console.error("Webcam Error:", err);
                window.isWebcamLoading = false;
                if (confirm("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥(å¯èƒ½æ˜¯æƒé™æˆ–è®¾å¤‡ä¸æ”¯æŒ)ï¼Œæ˜¯å¦åˆ‡æ¢åˆ°è§¦å±æ‰‹åŠ¿æ¨¡å¼ï¼Ÿ")) enableTouchSimMode();
                else { 
                    btn.classList.remove('active'); 
                    if(!isMobile) btn.innerText = "ğŸ“· æ‰‹åŠ¿æ§åˆ¶"; 
                    if(isMobile) btn.innerText = "ğŸ“· äº¤äº’";
                    updateStatus("å¯åŠ¨å¤±è´¥", "#ff5555"); 
                }
            }
        }

        function enableTouchSimMode() {
            window.isTouchMode = true;
            const btn = document.getElementById('btn-webcam');
            btn.classList.add('active');
            btn.style.boxShadow = "0 0 15px #00ffaa"; btn.style.color = "#00ffaa"; btn.style.borderColor = "#00ffaa";
            const isMobile = window.innerWidth <= 850;
            if (!isMobile) btn.innerText = "ğŸ‘† è§¦å±æ§åˆ¶";
            // æ‰‹æœºç«¯æ–‡æ¡ˆä¿æŒä¸å˜
            
            if(controls) controls.autoRotate = false;
            updateStatus("æ¨¡å¼ï¼šè§¦å±æ¨¡æ‹Ÿ", "#00ffaa");
        }

        function onTouchSimulate(e) {
            if (!window.isTouchMode || e.touches.length > 1) return;
            const t = e.touches[0];
            handX = (t.clientX / window.innerWidth - 0.5) * 2.5;
            handOpenness = Math.max(0, Math.min(1, (1.0 - t.clientY / window.innerHeight) * 1.2));
            const ind = document.getElementById('touch-indicator');
            ind.style.display = 'block';
            ind.style.left = t.clientX + 'px'; ind.style.top = t.clientY + 'px';
            ind.style.width = (40 + handOpenness * 30) + 'px'; ind.style.height = (40 + handOpenness * 30) + 'px';
            clearTimeout(window.touchHideTimer);
            window.touchHideTimer = setTimeout(() => ind.style.display = 'none', 200);
        }

        function initDraggable(el) {
            let isDragging = false; let startX, startY, initialLeft, initialTop;
            const onStart = (e) => {
                if(e.target.id === 'webcam-video' || e.target.id === 'output-canvas' || e.target.id === 'webcam-container') {
                    const evt = e.touches ? e.touches[0] : e;
                    startX = evt.clientX; startY = evt.clientY;
                    const rect = el.getBoundingClientRect();
                    initialLeft = rect.left; initialTop = rect.top;
                    
                    el.style.bottom = 'auto'; el.style.right = 'auto';
                    el.style.left = initialLeft + 'px'; el.style.top = initialTop + 'px';
                    
                    isDragging = true;
                    el.style.cursor = 'grabbing';
                }
            };
            const onMove = (e) => {
                if (!isDragging) return; e.preventDefault(); 
                const evt = e.touches ? e.touches[0] : e;
                el.style.left = (initialLeft + evt.clientX - startX) + 'px'; el.style.top = (initialTop + evt.clientY - startY) + 'px';
            };
            const onEnd = () => { if (isDragging) { isDragging = false; el.style.cursor = 'move'; } };
            el.addEventListener('mousedown', onStart); el.addEventListener('touchstart', onStart, {passive: false});
            window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove, {passive: false});
            window.addEventListener('mouseup', onEnd); window.addEventListener('touchend', onEnd);
        }

        function initPaintCanvas() {
            const isMobile = window.innerWidth <= 850;
            const wrapper = document.querySelector('.canvas-wrapper');
            const dpr = window.devicePixelRatio || 1;
            
            let w = 1200, h = 800;
            if (isMobile) {
                const rect = wrapper.getBoundingClientRect();
                w = rect.width; h = rect.height;
            } else {
                w = Math.min(1200, window.innerWidth * 0.95);
                h = Math.min(800, window.innerHeight * 0.9);
                wrapper.style.width = w + 'px'; wrapper.style.height = h + 'px';
            }
            
            paintCanvas.width = w * dpr; paintCanvas.height = h * dpr;
            paintCanvas.style.width = w + 'px'; paintCanvas.style.height = h + 'px';
            
            ctx.scale(dpr, dpr); ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = isMobile ? 4 : 8; ctx.lineCap = 'round'; ctx.lineJoin = 'round';

            paintCanvas.onmousedown = null; paintCanvas.ontouchstart = null;
            const getPos = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = paintCanvas.getBoundingClientRect();
                return [ clientX - rect.left, clientY - rect.top ];
            };
            const start = (e) => { if(e.type === 'touchstart') e.preventDefault(); isDrawing = true; [lastX, lastY] = getPos(e); };
            const move = (e) => { if (!isDrawing) return; if(e.type === 'touchmove') e.preventDefault(); const [x, y] = getPos(e); ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(x, y); ctx.stroke(); [lastX, lastY] = [x, y]; };
            const end = () => { isDrawing = false; };
            paintCanvas.addEventListener('mousedown', start); paintCanvas.addEventListener('mousemove', move); paintCanvas.addEventListener('mouseup', end); paintCanvas.addEventListener('mouseleave', end);
            paintCanvas.addEventListener('touchstart', start, {passive: false}); paintCanvas.addEventListener('touchmove', move, {passive: false}); paintCanvas.addEventListener('touchend', end);
        }

        window.confirmDrawing = () => {
             const w = paintCanvas.width; const h = paintCanvas.height;
             const data = ctx.getImageData(0, 0, w, h).data;
             const points = []; const step = 4;
             for(let y=0; y<h; y+=step) { for(let x=0; x<w; x+=step) { const idx = (y*w + x) * 4; if(data[idx] > 30) points.push({ x: (x/w - 0.5) * 40, y: -(y/h - 0.5) * 26 * (h/w), z: Math.sin(x/w * Math.PI * 4) * 2.0 }); } }
             if(points.length === 0) { alert("è¯·å…ˆç”»ç‚¹ä¸œè¥¿ï¼"); return; }
             const attr = particleSystem.geometry.attributes.targetCustom.array;
             for(let i=0; i<count; i++) {
                 const p = points[Math.floor(Math.random() * points.length)];
                 const i3 = i*3; attr[i3] = p.x + (Math.random()-0.5)*0.5; attr[i3+1] = p.y + (Math.random()-0.5)*0.5; attr[i3+2] = p.z + (Math.random()-0.5)*0.5;
             }
             particleSystem.geometry.attributes.targetCustom.needsUpdate = true;
             setMode('custom'); closeModal();
        };

        async function initMediaPipe() {
            if (window.hands) {
                detectLoop(); // Ensure loop restarts on subsequent opens
                return;
            }
            try {
                window.hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                window.hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                window.hands.onResults(onHandResults);
                window._handsErrorCount = 0; window._handsReady = false;
                detectLoop();
            } catch (e) { console.log("AI Init Error", e); }
        }

        function onHandResults(results) {
            const canvas = document.getElementById('output-canvas');
            const ctx = canvas.getContext('2d');
            const video = document.getElementById('webcam-video');
            if (canvas.width !== video.videoWidth) { canvas.width = video.videoWidth; canvas.height = video.videoHeight; }
            ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#00eaff', lineWidth: 2});
                drawLandmarks(ctx, landmarks, {color: '#ffaa33', lineWidth: 1, radius: 2});
                const wrist = landmarks[0]; const tip = landmarks[9];
                const palmLen = Math.hypot(wrist.x - tip.x, wrist.y - tip.y);
                let tipsDist = 0; [4,8,12,16,20].forEach(i => tipsDist += Math.hypot(wrist.x - landmarks[i].x, wrist.y - landmarks[i].y));
                const ratio = (tipsDist / 5) / palmLen;
                handOpenness = Math.max(0, Math.min(1, (ratio - 1.0) / 0.8));
                handX = (tip.x - 0.5) * 2; 
                updateStatus("ğŸŸ¢ æ•æ‰ä¸­", "#00ffaa");
            } else {
                handOpenness *= 0.9; handX *= 0.9;
                updateStatus("ğŸŸ¡ æœç´¢æ‰‹åŠ¿...", "#ffee00");
            }
            ctx.restore();
        }

        async function detectLoop() {
            const video = document.getElementById('webcam-video');
            if (window.isWebcamOn && video.paused) { try { await video.play(); } catch(e) {} }
            if (window.isWebcamOn) {
                try {
                    if(window.hands && video.readyState >= 2) {
                        await window.hands.send({image: video});
                        window._handsErrorCount = 0; window._handsReady = true;
                    }
                } catch(e) {
                    console.warn("Detection skipped frame", e);
                    window._handsErrorCount = (window._handsErrorCount || 0) + 1;
                    if (window._handsErrorCount > 15) {
                        console.error('Hands pipeline stalled, restarting...');
                        window.hands = null; // drop instance
                        setTimeout(initMediaPipe, 200); // restart after a brief pause
                        return;
                    }
                }
                requestAnimationFrame(detectLoop);
            }
        }

        function setMode(mode) {
            document.querySelectorAll('.shape-btn').forEach(b => { if(b.id !== 'btn-webcam' && b.id !== 'btn-immersive') b.classList.remove('active'); });
            document.getElementById('btn-'+mode).classList.add('active');
            material.uniforms.uWeightGalaxy.value = 0; material.uniforms.uWeightTesseract.value = 0; material.uniforms.uWeightMobius.value = 0; material.uniforms.uWeightCustom.value = 0;
            if(mode==='galaxy') material.uniforms.uWeightGalaxy.value = 1;
            if(mode==='tesseract') material.uniforms.uWeightTesseract.value = 1;
            if(mode==='mobius') material.uniforms.uWeightMobius.value = 1;
            if(mode==='custom') material.uniforms.uWeightCustom.value = 1;
        }

        function onDocumentMouseMove(event) { mouse.x = (event.clientX/window.innerWidth)*2-1; mouse.y = -(event.clientY/window.innerHeight)*2+1; }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
            checkMobileUI();
        }

        async function createMainParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(count * 3);
            const targetGalaxy = new Float32Array(count * 3);
            const targetTesseract = new Float32Array(count * 3);
            const targetMobius = new Float32Array(count * 3);
            const targetCustom = new Float32Array(count * 3); 
            const mixRatios = new Float32Array(count); 
            const sizes = new Float32Array(count);
            const randomness = new Float32Array(count * 3);
            // å¦‚æœå·¥ä½œç›®å½•ä¸‹æœ‰ model/ ä¸­çš„ glb/obj æ¨¡å‹ï¼Œå°è¯•åŠ è½½å¹¶é‡‡æ ·ç‚¹ä½œä¸ºç›®æ ‡
            const modelNames = { galaxy: 'zhaogongming', tesseract: 'zhaocaijinbao', mobius: 'laodian' };
            const sampled = {
                galaxy: await loadModelAsPoints(modelNames.galaxy, count),
                tesseract: await loadModelAsPoints(modelNames.tesseract, count),
                mobius: await loadModelAsPoints(modelNames.mobius, count)
            };

            // è‹¥æŸä¸ªé‡‡æ ·å¤±è´¥ï¼Œé€€å›åˆ°åŸæœ‰çš„ç”Ÿæˆé€»è¾‘çš„ç®€åŒ–å½¢å¼
            for(let i = 0; i < count; i++) {
                const i3 = i * 3;
                if(sampled.galaxy && sampled.galaxy.length === count * 3) {
                    targetGalaxy[i3] = sampled.galaxy[i3]; targetGalaxy[i3+1] = sampled.galaxy[i3+1]; targetGalaxy[i3+2] = sampled.galaxy[i3+2];
                } else {
                    const r = Math.random() * 20; const spin = r * 0.8; const branch = (i % 3) * ((Math.PI * 2) / 3);
                    targetGalaxy[i3] = Math.cos(branch + spin) * r + (Math.random()-0.5)*r*0.5; targetGalaxy[i3+1] = (Math.random()-0.5) * r * 0.5; targetGalaxy[i3+2] = Math.sin(branch + spin) * r + (Math.random()-0.5)*r*0.5;
                }

                if(sampled.tesseract && sampled.tesseract.length === count * 3) {
                    targetTesseract[i3] = sampled.tesseract[i3]; targetTesseract[i3+1] = sampled.tesseract[i3+1]; targetTesseract[i3+2] = sampled.tesseract[i3+2];
                } else {
                    const axis = Math.floor(Math.random() * 4);
                    let x = (Math.random()-0.5)*2; let y = (Math.random()-0.5)*2; let z = (Math.random()-0.5)*2; let w = (Math.random()-0.5)*2;
                    if(Math.random() > 0.05) { if(axis===0) { y=Math.round(y); z=Math.round(z); w=Math.round(w); } else if(axis===1) { x=Math.round(x); z=Math.round(z); w=Math.round(w); } else if(axis===2) { x=Math.round(x); y=Math.round(y); w=Math.round(w); } else { x=Math.round(x); y=Math.round(y); z=Math.round(z); } }
                    const rot = 0.8; let xw = x*Math.cos(rot) - w*Math.sin(rot); let ww = x*Math.sin(rot) + w*Math.cos(rot); x = xw; w = ww;
                    const scale = 12.0; const proj = scale / (3.0 - w); const tScatter = (Math.random() - 0.5) * 0.3; 
                    targetTesseract[i3] = x * proj + tScatter; targetTesseract[i3+1] = y * proj + tScatter; targetTesseract[i3+2] = z * proj + tScatter;
                }

                if(sampled.mobius && sampled.mobius.length === count * 3) {
                    targetMobius[i3] = sampled.mobius[i3]; targetMobius[i3+1] = sampled.mobius[i3+1]; targetMobius[i3+2] = sampled.mobius[i3+2];
                } else {
                    const mt = Math.random() * Math.PI * 2; const ms = (Math.random() - 0.5) * 5.0; const mR = 12.0; 
                    const mX = (mR + ms * Math.cos(mt/2)) * Math.cos(mt); const mY = (mR + ms * Math.cos(mt/2)) * Math.sin(mt); const mZ = ms * Math.sin(mt/2);
                    const mobiusScatter = (Math.random() - 0.5) * 3.0 * Math.pow(Math.random(), 2);
                    targetMobius[i3] = mX + mobiusScatter; targetMobius[i3+1] = mY + mobiusScatter; targetMobius[i3+2] = mZ + mobiusScatter;
                }

                // é»˜è®¤ custom ä½¿ç”¨ galaxy çš„æ ·å¼
                targetCustom[i3] = targetGalaxy[i3]; targetCustom[i3+1] = targetGalaxy[i3+1]; targetCustom[i3+2] = targetGalaxy[i3+2];
                const rmix = Math.hypot(targetGalaxy[i3], targetGalaxy[i3+1], targetGalaxy[i3+2]);
                mixRatios[i] = Math.min(rmix / 20, 1.0); sizes[i] = Math.random();
                randomness[i3] = (Math.random()-0.5) * 2; randomness[i3+1] = (Math.random()-0.5) * 2; randomness[i3+2] = (Math.random()-0.5) * 2;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('targetGalaxy', new THREE.BufferAttribute(targetGalaxy, 3));
            geometry.setAttribute('targetTesseract', new THREE.BufferAttribute(targetTesseract, 3));
            geometry.setAttribute('targetMobius', new THREE.BufferAttribute(targetMobius, 3));
            geometry.setAttribute('targetCustom', new THREE.BufferAttribute(targetCustom, 3));
            geometry.setAttribute('mixRatio', new THREE.BufferAttribute(mixRatios, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uWeightGalaxy: { value: 1.0 }, uWeightTesseract: { value: 0.0 }, uWeightMobius: { value: 0.0 }, uWeightCustom: { value: 0.0 },
                    uChaos: { value: 0 }, uSpread: { value: 0.0 }, 
                    uPixelRatio: { value: renderer.getPixelRatio() },
                    uColorInside: { value: new THREE.Color(0xffaa33) },
                    uColorOutside: { value: new THREE.Color(0x1b3984) },
                    uMouseWorld: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: `
                    uniform float uTime; uniform float uWeightGalaxy; uniform float uWeightTesseract; uniform float uWeightMobius; uniform float uWeightCustom;
                    uniform float uChaos; uniform float uSpread; uniform float uPixelRatio; uniform vec3 uColorInside; uniform vec3 uColorOutside; uniform vec3 uMouseWorld;
                    attribute vec3 targetGalaxy; attribute vec3 targetTesseract; attribute vec3 targetMobius; attribute vec3 targetCustom;
                    attribute float mixRatio; attribute float size; attribute vec3 randomness;
                    varying vec3 vColor;
                    vec3 getNoise(vec3 p) { return vec3(sin(p.y+uTime), sin(p.z+uTime), sin(p.x+uTime)); }
                    void main() {
                        // å…ˆæ ¹æ®å„æ¨¡å‹æƒé‡è®¡ç®—ç›®æ ‡ä½ç½®
                        vec3 pos = targetGalaxy * uWeightGalaxy + targetTesseract * uWeightTesseract + targetMobius * uWeightMobius + targetCustom * uWeightCustom;
                        float spreadDist = length(randomness);
                        vec3 spreadOffset = randomness * pow(spreadDist, 4.0) * uSpread * 10.0; 
                        pos += spreadOffset;
                        vec3 noise = getNoise(pos * 0.1) * 5.0;
                        vec3 chaosPos = pos + (randomness * 30.0 + noise) * uChaos;
                        vec3 finalPos = mix(pos, chaosPos, uChaos);
                        finalPos += normal * sin(uTime * 2.0) * 0.1;

                        // æ ¹æ®æœ€ç»ˆä½ç½®åˆ°ä¸­å¿ƒè·ç¦»è®¡ç®—é¢œè‰²æ’å€¼æ¯”ä¾‹ï¼Œä¿è¯æ‰€æœ‰æ¨¡å‹éƒ½èƒ½æ˜¾ç¤ºâ€œæ ¸å¿ƒ/è¾¹ç¼˜â€è¿‡æ¸¡
                        float distFromCenter = length(finalPos);
                        float ratio = clamp(distFromCenter / 20.0, 0.0, 1.0);
                        vColor = mix(uColorInside, uColorOutside, ratio);

                        // äº¤äº’
                        float dist = distance(finalPos.xy, uMouseWorld.xy);
                        if (dist < 8.0) {
                            float strength = pow((1.0 - dist / 8.0), 2.0);
                            vec3 pushDir = normalize(finalPos - vec3(uMouseWorld.xy, finalPos.z));
                            finalPos += pushDir * strength * 2.0;
                            float angle = strength * 3.0; 
                            float s = sin(angle); float c = cos(angle);
                            vec2 relPos = finalPos.xy - uMouseWorld.xy;
                            finalPos.xy = uMouseWorld.xy + vec2(relPos.x * c - relPos.y * s, relPos.x * s + relPos.y * c);
                        }
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = size * uPixelRatio * (150.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `varying vec3 vColor; void main() { float d = distance(gl_PointCoord, vec2(0.5)); if(d > 0.5) discard; float alpha = pow(1.0 - smoothstep(0.0, 0.5, d), 3.0); gl_FragColor = vec4(vColor, alpha); }`,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- æ¨¡å‹åŠ è½½ä¸é‡‡æ ·è¾…åŠ© ---
        async function loadModelAsPoints(name, count) {
            // é¿å…åœ¨ file:// åè®®ä¸‹ç›´æ¥ fetch æœ¬åœ°æ–‡ä»¶ï¼ˆä¼šè¢«æµè§ˆå™¨ CORS æ‹¦æˆªï¼‰
            if (location.protocol === 'file:') {
                console.warn('Running from file:// â€” skipping automatic model load for', name);
                updateStatus('è¿è¡Œåœ¨æœ¬åœ°æ–‡ä»¶ï¼Œæ¨¡å‹è¯·é€šè¿‡ä¸Šä¼ æˆ–æœ¬åœ°æœåŠ¡å™¨è®¿é—®', '#ffcc00');
                return null;
            }
            const base = 'model/' + name;
            const gltfLoader = new GLTFLoader();
            const objLoader = new OBJLoader();
            let sceneObj = null;
            // å…ˆå°è¯• glbï¼Œå†å°è¯• obj
            try {
                const gltf = await gltfLoader.loadAsync(base + '.glb');
                sceneObj = gltf.scene || (gltf.scenes && gltf.scenes[0]);
            } catch (e) {
                // GLB å¤±è´¥ï¼Œå°è¯• OBJï¼ˆç¤ºä¾‹ OBJLoader å¯èƒ½æ²¡æœ‰ loadAsyncï¼‰
                try {
                    sceneObj = await new Promise((resolve, reject) => {
                        objLoader.load(base + '.obj', (o) => resolve(o), undefined, (err) => reject(err));
                    });
                } catch (e2) {
                    console.warn('Model load failed for', name, e, e2);
                    return null;
                }
            }

            // åŸºäºä¸‰è§’å½¢çš„åŠ æƒé‡‡æ ·ï¼šæƒé‡ = é¢ç§¯ * (1 + curvatureFactor * æ›²ç‡)ï¼Œä»¥åœ¨é«˜æ›²ç‡åŒºåŸŸé‡‡æ ·æ›´å¤šç‚¹
            const trisPerMesh = [];
            let globalWeight = 0;
            sceneObj.updateMatrixWorld(true);
            sceneObj.traverse((mesh) => {
                if (!(mesh.isMesh && mesh.geometry && mesh.geometry.attributes && mesh.geometry.attributes.position)) return;
                let geom = mesh.geometry;
                if (!geom.isBufferGeometry) geom = new THREE.BufferGeometry().fromGeometry(geom);
                // ç¡®ä¿æ³•çº¿å­˜åœ¨
                if (!geom.attributes.normal) geom.computeVertexNormals();
                const pos = geom.attributes.position.array;
                const nor = geom.attributes.normal.array;
                const idxArr = geom.index ? geom.index.array : null;
                const triCount = idxArr ? idxArr.length / 3 : pos.length / 9;
                const tris = { mesh, triCount, triData: [], totalWeight: 0 };
                // é¢„è®¡ç®—æ¯ä¸ªä¸‰è§’å½¢çš„é¢ç§¯ä¸æ›²ç‡è¿‘ä¼¼
                const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
                const na = new THREE.Vector3(), nb = new THREE.Vector3(), nc = new THREE.Vector3();
                for (let t = 0; t < triCount; t++) {
                    const ia = idxArr ? idxArr[t*3] * 3 : t*9;
                    const ib = idxArr ? idxArr[t*3+1] * 3 : t*9 + 3;
                    const ic = idxArr ? idxArr[t*3+2] * 3 : t*9 + 6;
                    a.set(pos[ia], pos[ia+1], pos[ia+2]);
                    b.set(pos[ib], pos[ib+1], pos[ib+2]);
                    c.set(pos[ic], pos[ic+1], pos[ic+2]);
                    // area
                    const ab = new THREE.Vector3().subVectors(b, a);
                    const ac = new THREE.Vector3().subVectors(c, a);
                    const area = Math.max(0.000001, ab.cross(ac).length() * 0.5);
                    // vertex normals
                    na.set(nor[ia], nor[ia+1], nor[ia+2]);
                    nb.set(nor[ib], nor[ib+1], nor[ib+2]);
                    nc.set(nor[ic], nor[ic+1], nor[ic+2]);
                    // curvature approx: max angle between vertex normals
                    const angAB = Math.acos(Math.max(-1, Math.min(1, na.dot(nb))));
                    const angBC = Math.acos(Math.max(-1, Math.min(1, nb.dot(nc))));
                    const angCA = Math.acos(Math.max(-1, Math.min(1, nc.dot(na))));
                    const curvature = Math.max(angAB, angBC, angCA);
                    const curvatureFactor = 4.0; // å¯è°ƒï¼Œè¶Šå¤§è¶Šåå¥½æ›²ç‡é«˜çš„åŒºåŸŸ
                    const weight = area * (1.0 + curvatureFactor * curvature);
                    tris.triData.push({ ia, ib, ic, weight });
                    tris.totalWeight += weight;
                }
                if (tris.totalWeight > 0) {
                    globalWeight += tris.totalWeight;
                    trisPerMesh.push(tris);
                }
            });

            if (trisPerMesh.length === 0) return null;

            // å»ºç«‹æ¯ä¸ª mesh çš„ç´¯è®¡æƒé‡ç”¨äºå¿«é€Ÿé€‰æ‹©
            let accMesh = 0; for (const m of trisPerMesh) { accMesh += m.totalWeight; m.accum = accMesh; }
            const out = new Float32Array(count * 3);
            const PA = new THREE.Vector3(), PB = new THREE.Vector3(), PC = new THREE.Vector3();
            for (let i = 0; i < count; i++) {
                const rMesh = Math.random() * accMesh;
                let meshIdx = 0; while (rMesh > trisPerMesh[meshIdx].accum) meshIdx++;
                const meshInfo = trisPerMesh[meshIdx];
                // build cumulative for triangles lazily if not present
                if (!meshInfo.cumTri) {
                    meshInfo.cumTri = new Float64Array(meshInfo.triData.length);
                    let s = 0; for (let k = 0; k < meshInfo.triData.length; k++) { s += meshInfo.triData[k].weight; meshInfo.cumTri[k] = s; }
                }
                const totalTriW = meshInfo.cumTri[meshInfo.cumTri.length - 1];
                const rTri = Math.random() * totalTriW;
                // binary search triangle index
                let lo = 0, hi = meshInfo.cumTri.length - 1; while (lo < hi) { const mid = (lo + hi) >> 1; if (rTri <= meshInfo.cumTri[mid]) hi = mid; else lo = mid + 1; }
                const tri = meshInfo.triData[lo];
                const geom = meshInfo.mesh.geometry;
                const pos = geom.attributes.position.array;
                const ia = tri.ia, ib = tri.ib, ic = tri.ic;
                PA.set(pos[ia], pos[ia+1], pos[ia+2]); PB.set(pos[ib], pos[ib+1], pos[ib+2]); PC.set(pos[ic], pos[ic+1], pos[ic+2]);
                // uniform barycentric sampling
                const r1 = Math.random(); const r2 = Math.random(); const sr1 = Math.sqrt(r1);
                const u = 1 - sr1; const v = sr1 * (1 - r2); const w = sr1 * r2;
                const P = new THREE.Vector3(); P.set(0,0,0);
                P.addScaledVector(PA, u); P.addScaledVector(PB, v); P.addScaledVector(PC, w);
                // transform to world
                meshInfo.mesh.localToWorld(P);
                out[i*3] = P.x + (Math.random() - 0.5) * 0.005;
                out[i*3+1] = P.y + (Math.random() - 0.5) * 0.005;
                out[i*3+2] = P.z + (Math.random() - 0.5) * 0.005;
            }

            // å½’ä¸€åŒ–ç¼©æ”¾åˆ°ç”»é¢åˆé€‚å°ºå¯¸ï¼ˆç›®æ ‡åŠå¾„çº¦ 40ï¼‰
            let minX=1e9,minY=1e9,minZ=1e9,maxX=-1e9,maxY=-1e9,maxZ=-1e9;
            for (let i = 0; i < out.length; i += 3) {
                const x = out[i], y = out[i+1], z = out[i+2];
                if (x < minX) minX = x; if (y < minY) minY = y; if (z < minZ) minZ = z;
                if (x > maxX) maxX = x; if (y > maxY) maxY = y; if (z > maxZ) maxZ = z;
            }
            const sx = maxX - minX, sy = maxY - minY, sz = maxZ - minZ;
            const maxDim = Math.max(sx, sy, sz, 1e-6);
            const scale = 60.0 / maxDim;
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2, cz = (minZ + maxZ) / 2;
            for (let i = 0; i < out.length; i += 3) {
                out[i] = (out[i] - cx) * scale;
                out[i+1] = (out[i+1] - cy) * scale;
                out[i+2] = (out[i+2] - cz) * scale;
            }

            return out;
        }

        function collectMeshVerticesAsArray(obj) {
            const verts = [];
            obj.updateMatrixWorld(true);
            obj.traverse((c) => {
                if (c.isMesh && c.geometry && c.geometry.attributes.position) {
                    const pos = c.geometry.attributes.position;
                    const v = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i++) {
                        v.fromBufferAttribute(pos, i).applyMatrix4(c.matrixWorld);
                        verts.push(v.x, v.y, v.z);
                    }
                }
            });
            return verts;
        }

        function createBackgroundParticles() {
            const bgCount = 30000; const bgGeo = new THREE.BufferGeometry();
            const bgPos = new Float32Array(bgCount * 3); const bgSizes = new Float32Array(bgCount);
            for(let i=0; i<bgCount; i++) {
                const r = 70 + Math.random() * 150; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                bgPos[i*3] = r * Math.sin(phi) * Math.cos(theta); bgPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta); bgPos[i*3+2] = r * Math.cos(phi); bgSizes[i] = Math.random();
            }
            bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3)); bgGeo.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
            const bgMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color(0x1b3984) }, uPixelRatio: { value: renderer.getPixelRatio() } },
                vertexShader: `uniform float uTime; uniform float uPixelRatio; attribute float size; void main() { vec3 pos = position; float angle = uTime * 0.05; float s = sin(angle); float c = cos(angle); mat3 rot = mat3(c, 0, s, 0, 1, 0, -s, 0, c); vec4 mv = modelViewMatrix * vec4(pos * rot, 1.0); gl_Position = projectionMatrix * mv; gl_PointSize = size * 3.0 * uPixelRatio * (200.0 / -mv.z); }`,
                fragmentShader: `uniform vec3 uColor; void main() { float d = distance(gl_PointCoord, vec2(0.5)); if(d > 0.5) discard; gl_FragColor = vec4(uColor, 0.3 * (1.0 - d*2.0)); }`,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            bgParticles = { mesh: new THREE.Points(bgGeo, bgMat), material: bgMat };
            scene.add(bgParticles.mesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            if (window.isWebcamOn || window.isTouchMode) {
                smoothedOpenness += (handOpenness - smoothedOpenness) * 0.1;
                if(material) {
                    material.uniforms.uSpread.value = smoothedOpenness * 1.5;
                    material.uniforms.uChaos.value = smoothedOpenness * 0.5;
                }
                document.getElementById('spread-slider').value = smoothedOpenness * 1.5;
                document.getElementById('chaos-slider').value = smoothedOpenness * 0.5;
                if (Math.abs(handX) > 0.15) {
                    particleSystem.rotation.y += handX * 0.03;
                    if(controls) controls.autoRotate = false;
                }
            }
            if(material) {
                const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5); vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                material.uniforms.uMouseWorld.value.copy(camera.position.clone().add(dir.multiplyScalar(-camera.position.z / dir.z)));
                material.uniforms.uTime.value = time;
            }
            if(bgParticles) {
                bgParticles.material.uniforms.uTime.value = time;
                bgParticles.mesh.rotation.y = time * 0.02;
            }
            controls.update(); composer.render();
        }
    </script>
</body>
</html>